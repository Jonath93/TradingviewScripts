<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <div style="margin-top:10px;">
        <div id="chart_xauusd" style="width:100%;height:50vh;"></div>
    </div>
    <script src="/charting_library/charting_library.js"></script>
    <script src="/retrocesoScannerForex.js"></script>
    <script src="/datafeeduniversal.js"></script>
    <script>

        document.addEventListener("DOMContentLoaded", function () {
            let symbol = "XAU_USD";
            let interval = "15";
            let dataFeed = new UniversalDatafeed("forex", symbol);
            let ChartCreates = [];


            // xauusd Chart widget
            let xauusdWidget = new TradingView.widget({
                container: "chart_xauusd",
                library_path: "/charting_library/",
                symbol: symbol,  // ‚ö°Ô∏è aqu√≠ ya tu s√≠mbolo real
                interval: interval,      // carga inicial en 15m
                autosize: true,
                datafeed: dataFeed,
                locale: "en",
                disabled_features: [
                    "header_symbol_search",
                    "header_compare",
                    "timeframes_toolbar",
                    "use_localstorage_for_settings",
                    "create_study_template",
                    "save_chart_properties_to_local_storage",
                    "study_templates",
                    "header_resolutions",
                    "volume_force_overlay",
                    "show_volume_force_overlay",  // previene carga forzada

                ],
                enabled_features: [],
                overrides: {
                    "paneProperties.legendProperties.showSeriesTitle": false,
                    "paneProperties.legendProperties.showLegend": true, // mantiene los valores OHLC visibles
                    "symbolWatermarkProperties.color": "rgba(0,0,0,0)",

                },
                time_frames: [
                    { text: "2M", resolution: "60", description: "√öltimos 2 meses" }
                ],
            });
            xauusdWidget.onChartReady(() => {
                const chart = xauusdWidget.activeChart();

                // üîç Buscar y eliminar el estudio de volumen
                chart.getAllStudies().forEach(study => {
                    if (study.name.toLowerCase().includes("volume")) {
                        chart.removeEntity(study.id); // quita el estudio de volumen
                    }
                });


            });


            setInterval(() => {
                const chart = xauusdWidget.activeChart();

                const ResultScanner = dataFeed.GetResultScanner()


                if (ResultScanner) {
                    dibujarSetup(chart, ResultScanner);

                } else {
                    CleanChartsHelper(chart);

                }
            }, 5000);


            //funcions 
            // === Dibujar en el gr√°fico ===
            function dibujarSetup(chart, setup) {
                CleanChartsHelper(chart);

                const { fibs, ob, fvg, labels } = setup;

                CreatePositionLarge(chart, fibs, fibs.time)

                crearLabel(chart, fibs.fib35, `TP ${redondear2Decimales(labels.TP)}\npips:${extraerTresDigitos(labels.TP2Pips.toString())}`, "#66cc00", fibs.time);
                crearLabel(chart, fibs.fib67, `PE ${redondear2Decimales(labels.PE)}`, "#0099ff", fibs.time);
                crearLabel(chart, fibs.fib95, `SL ${redondear2Decimales(labels.SL)}\npips:${extraerTresDigitos(labels.SLPips.toString())}`, "#ff0000", fibs.time);

                if (ob) {
                    crearCaja(chart, ob.top, ob.bottom, "#ff3333", 0.4, fibs.time);
                }
                if (fvg) {
                    crearCaja(chart, fvg.top, fvg.bottom, "#ffff00", 0.4, fibs.time);
                }
            }



            // === Helpers gr√°ficos ===


            function crearLabel(chart, price, text, color = "#ffffff", time) {
                const visible = chart.getVisibleRange();
                if (!visible) return;
                const leftTime = visible.to + 16000;

                const now = Math.floor(time / 1000);
                chart.createMultipointShape(
                    [{ time: leftTime, price }],
                    {
                        shape: "comment",
                        text: text,
                        overrides: {
                            color: "#fff",
                            backgroundColor: color,  // fondo rojo (puedes cambiar tono)
                            fontsize: 12,
                            bold: true,
                            borderColor: color
                        }
                    }
                ).then(id => {
                    ChartCreates.push(id); // aqu√≠ s√≠ tienes el ID real
                });
            }


            function crearCaja(chart, top, bottom, color, opacity = 0.3, time) {
                const now = Math.floor(time / 1000);
                chart.createMultipointShape(
                    [
                        { time: now, price: top },
                        { time: now + 96000, price: bottom }
                    ],
                    {
                        shape: "rectangle",
                        overrides: {
                            color: color,           // borde
                            backgroundColor: color, // relleno
                            transparency: (1 - opacity) * 100
                        }
                    }
                ).then(id => {
                    ChartCreates.push(id); // aqu√≠ s√≠ tienes el ID real
                });
            }



            function CreatePositionLarge(chart, fibs, time) {
                // Obtener la √∫ltima vela visible en el gr√°fico
                const lastBarTime = Math.floor(time / 1000); // 1h antes
                const visible = chart.getVisibleRange();
                if (!visible) return;
                const leftTime = visible.to;
                // Posici√≥n larga en el √∫ltimo punto
                const entryPrice = fibs.fib67;   // precio actual aprox.
                const takeProfit = fibs.fib35;   // objetivo arriba
                const stopLoss = fibs.fib95;     // stop abajo


                createLine(chart, lastBarTime, leftTime, takeProfit, '#089981');
                createLine(chart, lastBarTime, leftTime, entryPrice, '#0099ff');
                createLine(chart, lastBarTime, leftTime, stopLoss, '#F23645');


            }
            function createLine(chart, time, leftTime, price, color) {
                chart.createMultipointShape(
                    [
                        { time: time, price: price },
                        { time: leftTime, price: price }
                    ],
                    {
                        shape: 'trend_line',
                        disableSelection: true,
                        disableSave: true,
                        overrides: {
                            linecolor: color,
                        }

                    }
                ).then(id => {
                    ChartCreates.push(id); // aqu√≠ s√≠ tienes el ID real
                });
            }
            function extraerTresDigitos(numStr) {
                // Asegura que sea n√∫mero v√°lido
                const num = Number(numStr);
                if (isNaN(num)) return null;

                // Caso 1: n√∫mero menor a 1 (tiene decimales relevantes)
                if (num < 1 && num > 0) {
                    return Math.floor(num * 10000); // multiplica por 10000 para captar "0.0236" ‚Üí 236
                }

                // Caso 2: n√∫mero mayor o igual a 1
                return Math.floor(num / Math.pow(10, Math.floor(Math.log10(num)) - 2));
            }

            function redondear2Decimales(valor) {
                // Convierte el valor a n√∫mero, redondea y elimina ceros innecesarios
                return parseFloat(parseFloat(valor).toFixed(2));
            }
            function CleanChartsHelper(chart) {
                ChartCreates.forEach(id => chart.removeEntity(id));
                ChartCreates = []; // limpia la lista
            }
        });
    </script>
</body>

</html>